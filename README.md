# Проєкт "Ресторан"

## Опис проєкту
**"Ресторан"** — це вебсистема, яка складається з двох частин:
- **Публічний інтерфейс** для відвідувачів ресторану (бронювання столів, перегляд меню);
- **Локальний інтерфейс** для працівників ресторану (обробка замовлень).

Уся логіка взаємодії реалізована через **BackEnd (Node.js, Express)**, а дані зберігаються у **MongoDB**.

---

## Структура проєкту


---

## Публічний інтерфейс

**Технології:**  
`React`, `Redux`, `styled-components`

**Функціонал:**
- Перегляд меню ресторану
- Резервування столу
- Відправлення замовлення на сервер

---

## Локальний інтерфейс

**Технології:**  
`React`, `Redux`, `styled-components`

**Функціонал:**
- Перегляд активних замовлень
- Зміна статусу замовлення
- Видалення завершених замовлень
- Перегляд історії замовлень

---

## BackEnd (Node.js + Express)

**Основні маршрути:**

| Метод | Маршрут | Опис |
|-------|----------|------|
| `POST` | `/orders` | Створення нового замовлення |
| `GET` | `/menu` | Отримання списку страв |
| `PUT` | `/orders/:id` | Змінення замовлення |
| `DELETE` | `/orders/:id` | Видалення завершеного замовлення |
| `POST` | `/history` | Збереження завершеного замовлення в історію |

---

## База даних (MongoDB)

**Колекції:**

### Меню (`menu`)
| Поле | Тип | Опис |
|------|-----|------|
| `Id` | String | Унікальний код страви |
| `name` | String | Назва страви |
| `ingredients` | [String] | Інгредієнти |
| `price` | Number | Ціна страви |

---

### Замовлення (`orders`)
| Поле | Тип | Опис |
|------|-----|------|
| `Id` | String | Унікальний код замовлення |
| `customerName` | String | Ім’я відвідувача |
| `items` | [Object] | Список замовлених страв |

---

### Історія замовлень (`history`)
| Поле           | Тип | Опис |
|----------------|-----|------|
| `Id`           | String | Код замовлення |
| `customerName` | String | Ім’я відвідувача |
| `items`        | [Object] | Список страв |
| `totalPrice`   | Number | Загальна ціна |
| `date`         | Date | Дата завершення замовлення |

---

### Резервування (`reservations`)
| Поле           | Тип | Опис |
|----------------|-----|------|
| `Id`           | String | Код бронювання |
| `customerName` | String | Ім’я відвідувача |
| `date`         | Date | Дата бронювання |

---

## Запуск проєкту

### 1. Клонування репозиторію:
```bash
git clone https://github.com/PepsaCola/nodeJS-project-Restaurant-.git
cd nodeJS-project-Restaurant-
```

### 2. Запускаєм проєкт:
```bash
npm start
```

## 2 ЛАБОРАТОРНА РОБОТА
## ПОСИЛАННЯ НА ER-ДІАГРАМУ - [ER-Діаграма](https://dbdiagram.io/d/diagram_restaurant-68f739122e68d21b417627e4)

## Опис даних та зв'язків

У системі ресторану використовуємо базу даних MongoDB, де зберігаються всі сутності, пов’язані з обслуговуванням клієнтів і внутрішньою роботою персоналу. Всього у нас є 7 таблиць (колекцій).

Основні колекції та їх зв’язки такі:

### 1. Employee (Працівники)

Містить дані про співробітників ресторану.

**Поля:**
* `_id` — унікальний ідентифікатор працівника;
* `name` — ім’я;
* `role` — посада (офіціант, кухар, адміністратор);
* `email`, `phone` — контакти.

**Зв’язки:** Один `Employee` може обробляти багато `Order` (1:N до багатьох).

### 2. Menu (Меню)

Містить інформацію про всі доступні страви.

**Поля:**
* `_id` — унікальний код страви;
* `dishName` — назва;
* `ingredients` — список інгредієнтів;
* `price` — ціна.

**Зв’язки:** Один пункт `Menu` може входити до багатьох `OrderItem` або `HistoryItem` (1:N до багатьох).

### 3. Order (Замовлення)

Зберігає активні замовлення відвідувачів.

**Поля:**
* `_id` — код замовлення;
* `customerName` — ім’я клієнта;
* `totalPrice` — підсумкова ціна;
* `status` — поточний стан (“active”, “completed”);
* `employee_id` — працівник, який виконує замовлення.

**Зв’язки:** Один `Order` містить кілька `OrderItem` (1:N до багатьох). Один `Employee` може мати кілька `Order`.

### 4. OrderItem (Позиція замовлення)

Допоміжна таблиця, що з’єднує `Menu` і `Order`.

**Поля:**
* `_id` — код позиції;
* `order_id` — посилання на конкретне замовлення;
* `menu_id` — посилання на страву;
* `quantity` — кількість одиниць.

**Зв’язки:** Кожен `OrderItem` належить одному `Order` і одній `Menu`.

### 5. History (Історія замовлень)

Містить усі завершені замовлення для аналітики.

**Поля:**
* `_id` — унікальний ідентифікатор;
* `customerName` — ім'я клієнта;
* `totalPrice` — підсумкова вартість;
* `date` — дата завершення.

**Зв’язки:** Один запис `History` має кілька `HistoryItem` (1:N до багатьох).

### 6. HistoryItem

Зберігає деталі кожного завершеного замовлення.

**Поля:**
* `_id` — унікальний ідентифікатор запису;
* `history_id` — посилання на конкретне виконане замовлення;
* `menu_id` — посилання на конкретну страву;
* `quantity` — кількість страв, замовлених клієнтом.

**Зв’язки:** Кожен `HistoryItem` посилається на одну страву (`Menu`) і на одне замовлення з історії (`History`).

### 7. Reservation (Резервування)

Містить інформацію про бронювання столиків.

**Поля:**
* `_id` — унікальний ідентифікатор бронювання;
* `customerName` — ім'я клієнта;
* `date` — дата та час бронювання;
* `tableNumber` — номер столика.

**Зв’язки:** Кожен клієнт може мати кілька бронювань (1:N до багатьох).

---

## Як дані оновлюються, змінюються та агрегуються

### 1. Створення замовлення

**Сценарій:** Клієнт через публічний інтерфейс вибирає страви та підтверджує замовлення.

**Процес:**
* Дані відправляються через `POST /orders`;
* На основі обраних страв із колекції `Menu` обчислюється `totalPrice`;
* Замовлення записується в колекцію `Order`;
* Відповідному працівнику (`Employee`) прив’язується `employee_id`.

### 2. Оновлення замовлення

**Сценарій:** Працівник у локальному інтерфейсі змінює статус замовлення.

**Процес:**
* Через `PUT /orders/:id` оновлюється поле `status`;
* Статуси можуть змінюватися: `active` → `completed`;
* Після завершення замовлення інформація копіюється в `History`.

### 3. Видалення замовлення

**Сценарій:** Після перенесення в історію замовлення видаляється з активних.

**Процес:**
* Через `DELETE /orders/:id`;
* Дані зберігаються в `History` і `HistoryItem` для аналітики.

### 4. Резервування столів

**Сценарій:** Клієнт бронює стіл на певну дату.

**Процес:**
* Через `POST /reservations`;
* Перевіряється, чи стіл вільний на цю дату;
* Якщо так — дані зберігаються в `Reservation`.

### 5. Агрегація даних (аналітика для адміністратора)

Використання MongoDB Aggregation Pipeline:

* **Популярні страви:** підрахунок кількості `menu_id` у `HistoryItem`;
* **Дохід за день:** сума `totalPrice` у `History` за певну дату;
* **Кількість замовлень працівника:** підрахунок `Order` за `employee_id`;
* **Кількість бронювань на день:** підрахунок `Reservation` за `date`.